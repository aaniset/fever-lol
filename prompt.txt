i want to show all orders in a table i am geting response of orders api like this 

{
    "message": "Orders fetched successfully",
    "orders": [
        {
            "orderId": "ORD-1739069178183-5pezl1iv4",
            "orderDate": "2025-02-09T02:46:18.183Z",
            "customerName": " ",
            "customerEmail": null,
            "eventName": "Winter Wonderland Jazz Night 2025",
            "eventId": "67a8151ade1b0f3fe39290c9",
            "organizerId": "67a7b3bdde1b0f3fe39290c0",
            "subtotal": null,
            "totalAmountPaid": 154.5,
            "paymentStatus": "completed",
            "orderStatus": "confirmed",
            "payoutStatus": "pending",
            "payoutAmount": 150,
            "event": {
                "name": "Winter Wonderland Jazz Night 2025",
                "date": "2025-02-09T06:00:00.000Z",
                "startTime": "03:00",
                "venue": "The Grand Ballroom",
                "address": null,
                "mapLink": null,
                "platformFee": "user",
                "paymentGatewayFee": "organizer"
            },
            "ticketDetails": [
                {
                    "type": "General Admission",
                    "quantity": 2,
                    "price": 75
                }
            ],
            "platformFee": 0,
            "paymentGatewayFee": 4.5,
            "discounts": 0,
            "paymentId": "pay_PtS52adVb8CVRW",
            "razorpayOrderId": "order_PtS4XecNF9S4uy"
        },
        {
            "orderId": "ORD-1739050968623-jmg83h1y5",
            "orderDate": "2025-02-08T21:42:48.623Z",
            "customerName": " ",
            "customerEmail": null,
            "eventName": "Winter Wonderland Jazz Night 2025",
            "eventId": "67a7b404de1b0f3fe39290c2",
            "organizerId": "67a7b3bdde1b0f3fe39290c0",
            "subtotal": null,
            "totalAmountPaid": 77.25,
            "paymentStatus": "completed",
            "orderStatus": "confirmed",
            "payoutStatus": "pending",
            "payoutAmount": 75,
            "event": {
                "name": "Winter Wonderland Jazz Night 2025",
                "date": "2025-02-09T06:00:00.000Z",
                "startTime": "02:00",
                "venue": "The Grand Ballroom",
                "address": null,
                "mapLink": null,
                "platformFee": "user",
                "paymentGatewayFee": "organizer"
            },
            "ticketDetails": [
                {
                    "type": "General Admission",
                    "quantity": 1,
                    "price": 75
                }
            ],
            "platformFee": 0,
            "paymentGatewayFee": 2.25,
            "discounts": 0,
            "paymentId": "pay_PtMuRENblAZhd7",
            "razorpayOrderId": "order_PtMtoskztxJPwP"
        }
    ]
}

but there are mistakes in the frontend for shoing this data correcly fix the error 

here is the frontend code 

"use client";
import { useEffect } from "react";
import { useState } from "react";
import { useSearchParams } from "next/navigation";
import { z } from "zod";
import { OrderSchema } from "@/models/orders";
import { OrderType } from "@/models/orders";
import axios from "axios";
import { CardContent } from "@/components/ui/card";
import { DataTable } from "./table/components/data-table";
import { columns } from "./table/components/columns";

export default function OrdersPage() {
  const searchParams = useSearchParams();
  const eventId = searchParams.get("eventId");
  const [isLoading, setIsLoading] = useState(true);
  const [orders, setOrders] = useState<OrderType[]>([]);
  useEffect(() => {
    axios
      .post(`/api/orders`, { eventId })
      .then((response) => {
        const allOrders = response.data?.orders;

        const cleanedOrder = z.array(OrderSchema).parse(allOrders);
        setOrders(cleanedOrder);
        setIsLoading(false);
      })
      .catch((error) => {
        console.error("Error fetching event details:", error);
        setIsLoading(false);
      });
  }, [eventId]);
  return (
    <main className="flex-1 overflow-auto">
      <div className="container mx-auto p-4">
        <CardContent className="p-0">
          <DataTable data={orders} columns={columns} isLoading={isLoading} />
        </CardContent>
      </div>
    </main>
  );
}


"use client";

import * as React from "react";
import {
  ColumnDef,
  ColumnFiltersState,
  SortingState,
  VisibilityState,
  flexRender,
  getCoreRowModel,
  getFacetedRowModel,
  getFacetedUniqueValues,
  getFilteredRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  useReactTable,
} from "@tanstack/react-table";

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";

import { DataTablePagination } from "./data-table-pagination";
import { DataTableToolbar } from "./data-table-toolbar";
import { Loading } from "./loading";
import { Button } from "@/components/ui/button";

interface DataTableProps<TData, TValue> {
  columns: ColumnDef<TData, TValue>[];
  data: TData[];
  isLoading: boolean;
}

export function DataTable<TData, TValue>({
  columns,
  data,
  isLoading,
}: DataTableProps<TData, TValue>) {
  const [mounted, setMounted] = React.useState(false);

  React.useEffect(() => {
    setMounted(true);
    return () => setMounted(false);
  }, []);

  const [rowSelection, setRowSelection] = React.useState({});
  const [columnVisibility, setColumnVisibility] =
    React.useState<VisibilityState>({});
  const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>(
    []
  );
  const [sorting, setSorting] = React.useState<SortingState>([]);

  const table = useReactTable({
    data,
    columns,
    state: {
      sorting,
      columnVisibility,
      rowSelection,
      columnFilters,
    },
    enableRowSelection: true,
    onRowSelectionChange: setRowSelection,
    onSortingChange: setSorting,
    onColumnFiltersChange: setColumnFilters,
    onColumnVisibilityChange: setColumnVisibility,
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getFacetedRowModel: getFacetedRowModel(),
    getFacetedUniqueValues: getFacetedUniqueValues(),
  });
  if (!mounted) {
    return null; // or a loading placeholder
  }
  return (
    <div className="w-full space-y-4">
      <DataTableToolbar table={table} />

      {isLoading ? (
        <Loading />
      ) : data.length === 0 ? (
        <div className="flex flex-1 py-16 items-center justify-center rounded-lg border border-dashed">
          {/* ... empty state content ... */}
          <div className="flex flex-col items-center gap-1 text-center">
            <h3 className="text-2xl font-bold tracking-tight">
              You have no orders
            </h3>
            <p className="text-sm text-muted-foreground">
              You can start selling as soon as you add an Event.
            </p>
            <Button className="mt-4">Add Event</Button>
          </div>
        </div>
      ) : (
        <div className="rounded-md border overflow-auto">
          <div className="min-w-full inline-block align-middle">
            <Table>
              <TableHeader>
                {/* ... existing header code ... */}
                {table.getHeaderGroups().map((headerGroup) => (
                  <TableRow key={headerGroup.id}>
                    {headerGroup.headers.map((header) => {
                      return (
                        <TableHead key={header.id} colSpan={header.colSpan}>
                          {header.isPlaceholder
                            ? null
                            : flexRender(
                                header.column.columnDef.header,
                                header.getContext()
                              )}
                        </TableHead>
                      );
                    })}
                  </TableRow>
                ))}
              </TableHeader>
              <TableBody>
                {/* ... existing body code ... */}
                {table.getRowModel().rows?.length ? (
                  table.getRowModel().rows.map((row) => (
                    <TableRow
                      key={row.id}
                      data-state={row.getIsSelected() && "selected"}
                    >
                      {row.getVisibleCells().map((cell) => (
                        <TableCell key={cell.id}>
                          {flexRender(
                            cell.column.columnDef.cell,
                            cell.getContext()
                          )}
                        </TableCell>
                      ))}
                    </TableRow>
                  ))
                ) : (
                  <TableRow>
                    <TableCell
                      colSpan={columns.length}
                      className="h-24 text-center"
                    >
                      No results.
                    </TableCell>
                  </TableRow>
                )}
              </TableBody>
            </Table>
          </div>
        </div>
      )}
      <DataTablePagination table={table} />
    </div>
  );
}


"use client";

import { ColumnDef } from "@tanstack/react-table";

import { Checkbox } from "@/components/ui/checkbox";

import {  orderStatuses, paymentStatuses,  } from "../data/data";
import { DataTableColumnHeader } from "./data-table-column-header";
import { DataTableRowActions } from "./data-table-row-actions";
import { OrderType } from "@/models/orders";

export const columns: ColumnDef<OrderType>[] = [
  {
    id: "select",
    header: ({ table }) => (
      <Checkbox
        checked={
          table.getIsAllPageRowsSelected() ||
          (table.getIsSomePageRowsSelected() && "indeterminate")
        }
        onCheckedChange={(value) => table.toggleAllPageRowsSelected(!!value)}
        aria-label="Select all"
        className="translate-y-[2px]"
      />
    ),
    cell: ({ row }) => (
      <Checkbox
        checked={row.getIsSelected()}
        onCheckedChange={(value) => row.toggleSelected(!!value)}
        aria-label="Select row"
        className="translate-y-[2px]"
      />
    ),
    enableSorting: false,
    enableHiding: false,
  },
  {

    accessorKey: "orderId",

    header: ({ column }) => (

      <DataTableColumnHeader column={column} title="Order ID" />

    ),

    cell: ({ row }) => (

      <div className="w-[80px]">{row.getValue("orderId")}</div>

    ),

    enableSorting: true,

    enableHiding: false,

  },

  {

    accessorKey: "orderDate",

    header: ({ column }) => (

      <DataTableColumnHeader column={column} title="Order Date" />

    ),

    cell: ({ row }) => (

      <div className="w-[100px]">

        {new Date(row.getValue("orderDate")).toLocaleDateString()}

      </div>

    ),

    enableSorting: true,

    enableHiding: false,

  },

  {

    accessorKey: "customerName",

    header: ({ column }) => (

      <DataTableColumnHeader column={column} title="Customer Name" />

    ),

    cell: ({ row }) => (

      <span className="max-w-[200px] truncate font-medium">

        {row.getValue("customerName")}

      </span>

    ),

    enableSorting: true,

    enableHiding: false,

  },

  {

    accessorKey: "eventName",

    header: ({ column }) => (

      <DataTableColumnHeader column={column} title="Event Name" />

    ),

    cell: ({ row }) => {

      // const event = events.find(

      //   (event) => event.value === row.original.eventName

      // );

      return (

        <span className="max-w-[200px] truncate font-medium">

          { row.getValue("eventName")}

        </span>

      );

    },

    enableSorting: true,

    enableHiding: false,

  },

  {

    accessorKey: "totalAmountPaid",

    header: ({ column }) => (

      <DataTableColumnHeader column={column} title="Total Amount Paid" />

    ),

    cell: ({ row }) => (

      <span className="font-medium">${row.getValue("totalAmountPaid")}</span>

    ),

    enableSorting: true,

    enableHiding: false,

  },
  {
    accessorKey: "paymentStatus",

    header: ({ column }) => (
      <DataTableColumnHeader column={column} title="Payment Status" />
    ),
    cell: ({ row }) => {
      const status = paymentStatuses.find(
        (status) => status.value === row.getValue("paymentStatus")
      );

      if (!status) {
        return null;
      }

      return (
        <div className="flex w-[100px] items-center">
          {status.icon && (
            <status.icon className="mr-2 h-4 w-4 text-muted-foreground" />
          )}
          <span>{status.label}</span>
        </div>
      );
    },
    filterFn: (row, id, value) => {
      return value.includes(row.getValue(id));
    },
  },
  {
    accessorKey: "orderStatus",
    header: ({ column }) => (
      <DataTableColumnHeader column={column} title="Order Status" />
    ),
    cell: ({ row }) => {
      const priority = orderStatuses.find(
        (priority) => priority.value === row.getValue("orderStatus")
      );

      if (!priority) {
        return null;
      }

      return (
        <div className="flex items-center">
          {priority.icon && (
            <priority.icon className="mr-2 h-4 w-4 text-muted-foreground" />
          )}
          <span>{priority.label}</span>
        </div>
      );
    },
    filterFn: (row, id, value) => {
      return value.includes(row.getValue(id));
    },
  },
  {
    id: "actions",
    cell: ({ row }) => <DataTableRowActions row={row} />,
  },
];


export const OrderSchema = z.object({
  _id: z.string(),
  orderId: z.string(),
  orderDate: z.string().datetime(),
  customerName: z.string(),
  customerEmail: z.string().email(),
  eventName: z.string(),
  eventId: z.string(),
  organizerId: z.string(),
  subtotal: z.number().nonnegative(),
  totalAmountPaid: z.number().nonnegative(),
  paymentStatus: z.enum(["failed", "success", "pending", "completed"]),
  orderStatus: z.enum(["confirmed", "cancelled", "pending"]),
  payoutStatus: z.enum(["pending", "completed", "failed"]),
  payoutAmount: z.number().nonnegative(),
  event: EventInfoSchema,
  ticketDetails: z.array(TicketDetailSchema),
  platformFee: z.number().nonnegative(),
  paymentGatewayFee: z.number().nonnegative(),
  discounts: z.number().nonnegative(),
});